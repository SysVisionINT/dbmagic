/**
 * Generated by SysVision DBMagic
 */
package ${packageName};

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import javax.naming.NamingException;
import javax.sql.DataSource;

import net.java.sjtools.error.UnexpectedError;
import net.java.sjtools.db.DBUtil;
import net.java.sjtools.db.NullReader;
import net.java.sjtools.db.pk.NativePrimaryKeyUtil;
import net.java.sjtools.util.JNDIUtil;
import net.java.sjtools.util.BeanUtil;
import net.java.sjtools.db.filter.Filter;
import net.java.sjtools.db.error.RecordNotFoundException;
import net.java.sjtools.db.error.RecordUpdateException;
import net.java.sjtools.db.error.SQLError;
#if(${loggerType} == "log")
import net.java.sjtools.logging.Log;
import net.java.sjtools.logging.LogFactory;
#else
import net.java.sjtools.logging.plus.RLog;
#end
import net.java.sjtools.db.sql.SQLUtil;

/**
 * Esta classe faz a gestão da tabela $entity.name
#if($entity.description)
 *
#foreach ($line in ${entity.getDescriptionLines()})	    
 * $line
#end
 *
#end 
 * @author SysVision DBMagic
 */ 
public class ${java.getName($entity)}PI {
#if(${loggerType} == "log")
    private static Log log = LogFactory.getLog(${java.getName($entity)}PI.class);
    
#end
    public static final String TABLE_NAME = "$entity.name";
    public static final String[] TABLE_COLUMNS = {#foreach ($coluna in ${entity.getAllColumnList()})#if ($velocityCount!=1), #end"$coluna.name"#end};
    public static final String[] OBJECT_ATTRIBUTES = {#foreach ($coluna in ${entity.getAllColumnList()})#if ($velocityCount!=1), #end"${java.getInnerName($coluna)}"#end};    
    public static final String[] JAVA_TYPES = {#foreach ($coluna in ${entity.getAllColumnList()})#if ($velocityCount!=1), #end"${java.getJavaType($coluna)}"#end};        
			        
    private DataSource dataSource = null;
    
    protected ${java.getName($entity)}PI(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    /**
     * Devolve uma instancia da classe ${java.getName($entity)}PI
     * @param jndiName Nome JNDI do datasource a utilizar para aceder à tabela $entity.name
     * @return Instancia da classe ${java.getName($entity)}PI
     * @throws NamingException Se ocorrer um erro no acesso ao serviço JNDI
     */
    public static ${java.getName($entity)}PI getInstance(String jndiName) throws NamingException {
        return getInstance((DataSource)JNDIUtil.getJNDIObject(jndiName));
    }

    /**
     * Devolve uma instancia da classe ${java.getName($entity)}PI
     * @param dataSource Datasource a utilizar para aceder à tabela $entity.name
     * @return Instancia da classe ${java.getName($entity)}PI
     */
    public static ${java.getName($entity)}PI getInstance(DataSource dataSource) {
        return new ${java.getName($entity)}PI(dataSource);
    }
    
    protected DataSource getDataSource() {
        return dataSource;
    }
#if ($model.hasKeyGenerator($entity))  

    protected ${entity.primaryKey.keyGenerator.column.javaType} getPrimaryKeyValue(${java.getName($entity)} obj) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("getPrimaryKeyValue(" + obj + ")");
        }
		        
        ${entity.primaryKey.keyGenerator.column.javaType} ret = 1;
        
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        
#if ($model.isKeyGeneratorMax($entity))
        int defaultLevel = -1;

#end                            
        try {
            con = DBUtil.getConnection(getDataSource());
            
#if ($model.isKeyGeneratorMax($entity))
            try {
                defaultLevel = con.getTransactionIsolation();
                con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
            } catch (SQLException e) {}

#end                    
            StringBuffer buffer = new StringBuffer();
            buffer.append("${sql.getSelectKeyGenerator($entity)}");
#if ($model.isKeyGeneratorNative($entity))
#foreach ($coluna in ${entity.getColumnList()})

#if ($java.isValidGeneratorNativeColumn($coluna))
            if (obj.${java.getInnerName($coluna)}Changed) {
                buffer.append(" AND ${coluna.name}=?");
            }
#end
#end        
#if ($model.hasVersionControl($entity))

            buffer.append(" AND ${entity.versionControlColumn.column.name}=1");  
#end          
#end  

            ps = con.prepareStatement(buffer.toString()#if ($model.isKeyGeneratorTable($entity)), ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE#end);
#if ($model.isKeyGeneratorMax($entity))

#foreach ($coluna in ${entity.primaryKey.keyGenerator.getMaxColumnList()})
            ps.${java.getJavaTypeSetter($coluna)}($velocityCount, obj.${java.getGetter($coluna)}());
#end
#end
#if ($model.isKeyGeneratorNative($entity))

            int column = 1;            
#foreach ($coluna in $entity.getColumnList())

#if ($java.isValidGeneratorNativeColumn($coluna))
            if (obj.${java.getInnerName($coluna)}Changed) {
#if($java.isWrapperClass($coluna))

                if (obj.${java.getGetter($coluna)}() == null) {
                    ps.setNull(column++, Types.$java.getSQLType($coluna));
                } else {
                    ps.${java.getJavaTypeSetter($coluna)}(column++, obj.${java.getGetter($coluna)}()#if($java.isWrapperClass($coluna))$java.primitiveGetter($coluna)#end);                        
                }
        
#else
                ps.${java.getJavaTypeSetter($coluna)}(column++, obj.${java.getGetter($coluna)}());
#end                
            }
#end            
#end
#end

            rs = ps.executeQuery();

            if (rs.next()) {
                ret = rs.${java.getJavaTypeGetter(${entity.primaryKey.keyGenerator.column})}(1);                
#if ($model.isKeyGeneratorMax($entity))

                ret++;
#end
#if ($model.isKeyGeneratorTable($entity)) 

                ret++;
			                rs.updateLong("$model.getKeyGeneratorTableValueColumn($entity)", ret + 1);
			                rs.updateRow();
#end
#if ($model.isKeyGeneratorNative($entity))

                if (rs.wasNull()) {
                    throw new SQLException("Unable to find the value of ${entity.primaryKey.keyGenerator.column.name} for record " + obj);
                }
#end             
#if (!$model.isKeyGeneratorTable($entity)) 
            }                       
#else
            } else {
                DBUtil.close(rs);
                DBUtil.close(ps);
            	    
                ps = con.prepareStatement("${sql.getTableGeneratorInsert($entity)}");
            	    
                ps.executeUpdate();
            }
#end
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing getPrimaryKeyValue(" + obj + ")", e);
            throw new SQLError(e);
        } catch (Throwable e) {     
            ${loggerType}.error("Exception catched while executing getPrimaryKeyValue(" + obj + ")", e);
            throw new UnexpectedError(e);            
        } finally {
#if ($model.isKeyGeneratorMax($entity))
            if (defaultLevel != -1) {
                try {
                    con.setTransactionIsolation(defaultLevel);
                } catch (SQLException e) {}
            }

#end        
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        return ret;
    }
#end  
#if (!$entity.readOnly)    

    /**
     * Permite criar um registo na tabela $entity.name
     * @param obj Instancia da classe ${java.getName($entity)} que contem os dados referentes ao registo a criar
     * @return Instancia da classe ${java.getName($entity)} que contem os dados inseridos
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     */
    public ${java.getName($entity)} create(${java.getName($entity)} obj) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("create(" + obj + ")");
        }
		            
        ${java.getName($entity)} ret = obj.copyOf();    
#if ($model.hasKeyGenerator($entity))             
#if (!$model.isKeyGeneratorNative($entity))

        ret.${java.getSetter(${entity.primaryKey.keyGenerator.column})}(getPrimaryKeyValue(ret));
#end
#end
        
        StringBuffer buffer = new StringBuffer();
        buffer.append("INSERT INTO ${entity.name} (#if (!$model.isKeyGeneratorNative($entity))#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($velocityCount==1)${coluna.name}#else, ${coluna.name}#end#end#end");
#if (!$model.hasPrimaryKey($entity) || $model.isKeyGeneratorNative($entity))         

        boolean first = true;  
#end
        
#foreach ($coluna in ${entity.getColumnList()})
#if ($model.hasPrimaryKey($entity) && !$model.isKeyGeneratorNative($entity))
        if (ret.${java.getInnerName($coluna)}Changed) {
            buffer.append(", ${coluna.name}");
        }
#else
        if (ret.${java.getInnerName($coluna)}Changed) {
            if (first) {
                buffer.append("${coluna.name}");
                first = false;
            } else {
                buffer.append(", ${coluna.name}");
            }
        }
#end        
        
#end
#if ($model.hasVersionControl($entity))
        buffer.append(", ${entity.versionControlColumn.column.name}");
#end
        buffer.append(") VALUES (#if (!$model.isKeyGeneratorNative($entity))#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($velocityCount==1)?#else, ?#end#end#end");
#if (!$model.hasPrimaryKey($entity) || $model.isKeyGeneratorNative($entity))

        first = true;
#end
#foreach ($coluna in ${entity.getColumnList()})

#if ($model.hasPrimaryKey($entity) && !$model.isKeyGeneratorNative($entity))
        if (ret.${java.getInnerName($coluna)}Changed) {
            buffer.append(", ?");
        }
#else
        if (ret.${java.getInnerName($coluna)}Changed) {
            if (first) {
                buffer.append("?");
                first = false;
            } else {
                buffer.append(", ?");
            }
        }
#end         

#end       
#if ($model.hasVersionControl($entity))
        buffer.append(", 1");
#end
        buffer.append(")");
    
        Connection con = null;
        PreparedStatement ps = null;

        try {
            con = DBUtil.getConnection(getDataSource());
            ps = con.prepareStatement(buffer.toString());

            int column = 1;
            
#if (!$model.isKeyGeneratorNative($entity))
#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})
#if($java.isWrapperClass($coluna))

            if (ret.${java.getGetter($coluna)}() == null) {
                ps.setNull(column++, Types.$java.getSQLType($coluna));
            } else {
                ps.${java.getJavaTypeSetter($coluna)}(column++, ret.${java.getGetter($coluna)}()#if($java.isWrapperClass($coluna))$java.primitiveGetter($coluna)#end);                        
            }
        
#else
            ps.${java.getJavaTypeSetter($coluna)}(column++, ret.${java.getGetter($coluna)}());
#end
#end
#end
#foreach ($coluna in ${entity.getColumnList()})

            if (ret.${java.getInnerName($coluna)}Changed) {
#if($java.isWrapperClass($coluna))
                if (ret.${java.getGetter($coluna)}() == null) {
                    ps.setNull(column++, Types.$java.getSQLType($coluna));
                } else {
                    ps.${java.getJavaTypeSetter($coluna)}(column++, ret.${java.getGetter($coluna)}()#if($java.isWrapperClass($coluna))$java.primitiveGetter($coluna)#end);                        
                }
#else
                ps.${java.getJavaTypeSetter($coluna)}(column++, ret.${java.getGetter($coluna)}());
#end
            }
#end

            ps.executeUpdate();
            
#if ($model.hasVersionControl($entity))
            ret.${java.getSetter($entity.versionControlColumn.column)}(1);
#end            
#if ($model.isKeyGeneratorNative($entity))
            ${entity.primaryKey.keyGenerator.column.javaType} key = (${entity.primaryKey.keyGenerator.column.javaType})NativePrimaryKeyUtil.getPrimaryKey(con);
            
            if (key == NativePrimaryKeyUtil.KEY_NOT_FOUND) {
                key = getPrimaryKeyValue(ret);
            }
            
            ret.${java.getSetter(${entity.primaryKey.keyGenerator.column})}(key);
#end
            ret.setChanged(false);
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing create(" + obj + ")", e);
            throw new SQLError(e);    
        } catch (Exception e) {   
            ${loggerType}.error("Exception catched while executing create(" + obj + ")", e);
            throw new UnexpectedError(e);                             
        } finally {
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        if (${loggerType}.${loggerLevelEnable}()) {
            ${loggerType}.${loggerLevel}("Record " + ret + " inserted on table $entity.name");
        }

        return ret;
    }
#if ($model.hasPrimaryKey($entity))   
 
    /**
     * Permite remover um registo na tabela $entity.name
     * @param obj Instancia da classe ${java.getName($entity)} que representa o registo a eliminar
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado
     * @throws RecordUpdateException Se não foi apagado um e um só registo
     */
    public void remove(${java.getName($entity)} obj) throws SQLError, UnexpectedError, RecordUpdateException {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("remove(" + obj + ")");
        }
		            
        Connection con = null;
        PreparedStatement ps = null;

        try {
            con = DBUtil.getConnection(getDataSource());
            ps = con.prepareStatement("${sql.getDelete($entity)}");

#set($primeira=1)
#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})
#if($java.isWrapperClass($coluna))

            if (obj.${java.getGetter($coluna)}() == null) {
                ps.setNull($primeira, Types.$java.getSQLType($coluna));
            } else {
                ps.${java.getJavaTypeSetter($coluna)}($primeira, obj.${java.getGetter($coluna)}()#if($java.isWrapperClass($coluna))$java.primitiveGetter($coluna)#end);                        
            }
        
#else
            ps.${java.getJavaTypeSetter($coluna)}($primeira, obj.${java.getGetter($coluna)}());
#end
#set($primeira=$primeira+1)
#end
#if ($model.hasVersionControl($entity))
            ps.${java.getJavaTypeSetter($entity.versionControlColumn.column)}($primeira, obj.${java.getGetter($entity.versionControlColumn.column)}());
#end

            int changes = ps.executeUpdate();
            
            if (changes != 1) {
                ${loggerType}.error("remove(" + obj + ") affected more than one row");
                throw new RecordUpdateException(RecordUpdateException.DELETE, 1, changes);
            }
        } catch (RecordUpdateException e) {     
            throw e;            
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing remove(" + obj + ")", e);
            throw new SQLError(e);          
        } catch (Exception e) {    
            ${loggerType}.error("Exception catched while executing remove(" + obj + ")", e);
            throw new UnexpectedError(e);                                 
        } finally {
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        if (${loggerType}.${loggerLevelEnable}()) {
            ${loggerType}.${loggerLevel}("Record " + obj + " deleted from table $entity.name");
        }        
    }    

#if ($model.isUpdateable($entity))    
    /**
     * Permite alterar um registo na tabela $entity.name
     * @param obj Instancia da classe ${java.getName($entity)} que contem os dados referentes ao registo a alterar
     * @return Instancia da classe ${java.getName($entity)} que contem os dados alterados
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     * @throws RecordUpdateException Se não foi alterado um e um só registo	     
     */    
    public ${java.getName($entity)} update(${java.getName($entity)} obj) throws SQLError, UnexpectedError, RecordUpdateException {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("update(" + obj + ")");
        }
		            
        ${java.getName($entity)} ret = obj.copyOf();
        
        if (!obj.isChanged()) {
            return ret;
        }
            
        StringBuffer buffer = new StringBuffer();
        buffer.append("UPDATE ${entity.name} SET ");
        
        boolean first = true;
        
#foreach ($coluna in ${entity.getColumnList()})
        if (obj.${java.getInnerName($coluna)}Changed) {
            if (first) {
                buffer.append("${coluna.name}=?");
                first = false;
            } else {
                buffer.append(", ${coluna.name}=?");
            }
        }
         
#end        
#if ($model.hasVersionControl($entity))
        buffer.append(", ${entity.versionControlColumn.column.name}=${entity.versionControlColumn.column.name}+1");        
#end
        buffer.append(" WHERE #foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($velocityCount==1)${coluna.name}=?#else AND ${coluna.name}=?#end#end");
#if ($model.hasVersionControl($entity))
        buffer.append(" AND ${entity.versionControlColumn.column.name}=?");
#end

        Connection con = null;
        PreparedStatement ps = null;

        try {
            con = DBUtil.getConnection(getDataSource());
            ps = con.prepareStatement(buffer.toString());

            int column = 1;

#foreach ($coluna in ${entity.getColumnList()})
            if (obj.${java.getInnerName($coluna)}Changed) {
#if($java.isWrapperClass($coluna))
                if (obj.${java.getGetter($coluna)}() == null) {
                    ps.setNull(column++, Types.$java.getSQLType($coluna));
                } else {
                    ps.${java.getJavaTypeSetter($coluna)}(column++, obj.${java.getGetter($coluna)}()#if($java.isWrapperClass($coluna))$java.primitiveGetter($coluna)#end);                        
                }    
#else
                ps.${java.getJavaTypeSetter($coluna)}(column++, obj.${java.getGetter($coluna)}());
#end
            }

#end
#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})
#if($java.isWrapperClass($coluna))

            if (obj.${java.getGetter($coluna)}() == null) {
                ps.setNull(column++, Types.$java.getSQLType($coluna));
            } else {
                ps.${java.getJavaTypeSetter($coluna)}(column++, obj.${java.getGetter($coluna)}()#if($java.isWrapperClass($coluna))$java.primitiveGetter($coluna)#end);                        
            }
        
#else
            ps.${java.getJavaTypeSetter($coluna)}(column++, obj.${java.getGetter($coluna)}());
#end
#end
#if ($model.hasVersionControl($entity))
            ps.${java.getJavaTypeSetter($entity.versionControlColumn.column)}(column++, obj.${java.getGetter($entity.versionControlColumn.column)}());
#end

            int changes = ps.executeUpdate();
            
            if (changes != 1) {
                ${loggerType}.error("update(" + obj + ") affected more than one row");
                throw new RecordUpdateException(RecordUpdateException.UPDATE, 1, changes);
            }
            
#if ($model.hasVersionControl($entity))
            ret.${java.getSetter($entity.versionControlColumn.column)}(ret.${java.getGetter($entity.versionControlColumn.column)}() + 1);
#end        
            ret.setChanged(false);    
        } catch (RecordUpdateException e) {     
            throw e;              
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing update(" + obj + ")", e);
            throw new SQLError(e);           
        } catch (Exception e) {               
            ${loggerType}.error("Exception catched while executing update(" + obj + ")", e);
            throw new UnexpectedError(e);                
        } finally {
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        if (${loggerType}.${loggerLevelEnable}()) {
            ${loggerType}.${loggerLevel}("Record " + ret + " updated on table $entity.name");
        } 
        
        return ret;
    } 
#end
#end  
#end
#if ($model.hasPrimaryKey($entity))    

    /**
     * Permite determinar a existência de um registo na tabela $entity.name através da chave primária
     * @param obj Instancia da classe ${java.getName($entity)} que representa o registo a procurar
     * @return true caso exista ou false caso contrário
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     */
    public boolean exists(${java.getName($entity)} obj) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("exists(" + obj + ")");
        }
		            
        return exists(#set($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)#set($primeira=0)obj.${java.getGetter($coluna)}()#else, obj.${java.getGetter($coluna)}()#end#end);
    }

    /**
     * Permite determinar a existência de um registo na tabela $entity.name através da chave primária
#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})	     
     * @param ${java.getInnerName($coluna)} Indica o valor da coluna $coluna.name
#end	     
     * @return true caso exista ou false caso contrário
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     */
    public boolean exists(#set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)${java.getJavaType($coluna)} ${java.getInnerName($coluna)}#set ($primeira=0)#else, ${java.getJavaType($coluna)} ${java.getInnerName($coluna)}#end#end) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("exists(" + #set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)${java.getInnerName($coluna)}#set ($primeira=0)#else + ", " + ${java.getInnerName($coluna)}#end#end + ")");
        }
		            
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        try {
            con = DBUtil.getConnection(getDataSource());
            ps = con.prepareStatement("${sql.getExists($entity)}", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);

#set($primeira=1)
#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})
            ps.${java.getJavaTypeSetter($coluna)}($primeira, ${java.getInnerName($coluna)});
#set($primeira=$primeira+1)
#end

            rs = ps.executeQuery();

            if (rs.next()) {
               return rs.getLong(1) > 0;
            }
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing exists(" + #set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)${java.getInnerName($coluna)}#set ($primeira=0)#else + ", " + ${java.getInnerName($coluna)}#end#end + ")", e);
            throw new SQLError(e);           
        } catch (Exception e) {     
            ${loggerType}.error("Exception catched while executing exists(" + #set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)${java.getInnerName($coluna)}#set ($primeira=0)#else + ", " + ${java.getInnerName($coluna)}#end#end + ")", e);
            throw new UnexpectedError(e);                 
        } finally {
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        return false;
    }

    /**
     * Permite obter o registo da tabela $entity.name através da chave primária
#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})	     
     * @param ${java.getInnerName($coluna)} Indica o valor da coluna $coluna.name
#end	     
     * @return Instancia da classe ${java.getName($entity)} que representa o registo indicado
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     * @throws RecordNotFoundException Se o registo não existir
     */
    public ${java.getName($entity)} findByPK(#set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)${java.getJavaType($coluna)} ${java.getInnerName($coluna)}#set ($primeira=0)#else, ${java.getJavaType($coluna)} ${java.getInnerName($coluna)}#end#end) throws SQLError, UnexpectedError, RecordNotFoundException {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("findByPK(" + #set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)${java.getInnerName($coluna)}#set ($primeira=0)#else + ", " + ${java.getInnerName($coluna)}#end#end + ")");
        }
		            
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        
        ${java.getName($entity)} obj = null;

        try {
            con = DBUtil.getConnection(getDataSource());
            ps = con.prepareStatement("${sql.getSelectByPK($entity)}", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);

#set($primeira=1)
#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})
            ps.${java.getJavaTypeSetter($coluna)}($primeira, ${java.getInnerName($coluna)});
#set($primeira=$primeira+1)
#end

            rs = ps.executeQuery();

            if (!rs.next()) {
                if (${loggerType}.isDebugEnabled()) {
                    ${loggerType}.debug("Unable to find record #set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)FROM $entity.name WHERE $coluna.name = " + ${java.getInnerName($coluna)} + "#set ($primeira=0)#else AND $coluna.name = " + ${java.getInnerName($coluna)} + "#end#end!");
                }

                throw new RecordNotFoundException(#set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)"FROM $entity.name WHERE $coluna.name = " + ${java.getInnerName($coluna)}#set ($primeira=0)#else + " AND $coluna.name = " + ${java.getInnerName($coluna)}#end#end);
            }

            obj = readObject(rs);
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing findByPK(" + #set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)${java.getInnerName($coluna)}#set ($primeira=0)#else + ", " + ${java.getInnerName($coluna)}#end#end + ")", e);
            throw new SQLError(e);     
        } catch (RecordNotFoundException e) { 
            throw e;        
        } catch (Exception e) {     
            ${loggerType}.error("Exception catched while executing findByPK(" + #set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)${java.getInnerName($coluna)}#set ($primeira=0)#else + ", " + ${java.getInnerName($coluna)}#end#end + ")", e);
            throw new UnexpectedError(e);                 
        } finally {
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        return obj;
    }     
#if ($model.hasVersionControl($entity))
#if ($model.isUpdateable($entity))    

    /**
     * Permite obter o registo da tabela $entity.name através da chave primária, mantendo um lock que impede alterações
#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})	     
     * @param ${java.getInnerName($coluna)} Indica o valor da coluna $coluna.name
#end	     
     * @return Instancia da classe ${java.getName($entity)} que representa o registo indicado
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     * @throws RecordNotFoundException Se o registo não existir
     */
    public ${java.getName($entity)} findByPKWithLock(#set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)${java.getJavaType($coluna)} ${java.getInnerName($coluna)}#set ($primeira=0)#else, ${java.getJavaType($coluna)} ${java.getInnerName($coluna)}#end#end) throws SQLError, UnexpectedError, RecordNotFoundException {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("findByPKWithLock(" + #set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)${java.getInnerName($coluna)}#set ($primeira=0)#else + ", " + ${java.getInnerName($coluna)}#end#end + ")");
        }
        
        StringBuffer buffer = new StringBuffer();
        buffer.append("UPDATE ${entity.name} SET ${entity.versionControlColumn.column.name}=${entity.versionControlColumn.column.name}");
        buffer.append(" WHERE #foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($velocityCount==1)${coluna.name}=?#else AND ${coluna.name}=?#end#end");

        Connection con = null;
        PreparedStatement ps = null;

        try {
            con = DBUtil.getConnection(getDataSource());
            ps = con.prepareStatement(buffer.toString());

#set($primeira=1)
#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})
            ps.${java.getJavaTypeSetter($coluna)}($primeira, ${java.getInnerName($coluna)});
#set($primeira=$primeira+1)
#end

            int changes = ps.executeUpdate();
            
            if (changes != 1) {
                if (${loggerType}.isDebugEnabled()) {
                    ${loggerType}.debug("Unable to find record #set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)FROM $entity.name WHERE $coluna.name = " + ${java.getInnerName($coluna)} + "#set ($primeira=0)#else AND $coluna.name = " + ${java.getInnerName($coluna)} + "#end#end!");
                }

                throw new RecordNotFoundException(#set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)"FROM $entity.name WHERE $coluna.name = " + ${java.getInnerName($coluna)}#set ($primeira=0)#else + " AND $coluna.name = " + ${java.getInnerName($coluna)}#end#end);
            }
                 
            return findByPK(#set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)${java.getInnerName($coluna)}#set ($primeira=0)#else, ${java.getInnerName($coluna)}#end#end);         
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing findByPKWithLock(" + #set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)${java.getInnerName($coluna)}#set ($primeira=0)#else + ", " + ${java.getInnerName($coluna)}#end#end + ")", e);
            throw new SQLError(e);     
        } catch (RecordNotFoundException e) { 
            throw e;        
        } catch (Exception e) {     
            ${loggerType}.error("Exception catched while executing findByPKWithLock(" + #set ($primeira=1)#foreach ($coluna in ${entity.getPrimaryKey().getColumnList()})#if ($primeira==1)${java.getInnerName($coluna)}#set ($primeira=0)#else + ", " + ${java.getInnerName($coluna)}#end#end + ")", e);
            throw new UnexpectedError(e);                 
        } finally {
            DBUtil.close(ps);
            DBUtil.close(con);
        }
    }
#end     
#end    
#end     

    protected ${java.getName($entity)} readObject(ResultSet rs) throws SQLException {
        ${java.getName($entity)} obj = new ${java.getName($entity)}();

#foreach ($coluna in ${entity.getAllColumnList()})
#if (${java.isWrapperClass($coluna)})
        obj.${java.getSetter($coluna)}(NullReader.${java.getJavaTypeGetter($coluna)}(rs, "${coluna.name}"));
#else
        obj.${java.getSetter($coluna)}(rs.${java.getJavaTypeGetter($coluna)}("${coluna.name}"));
#end
#end
#if (!$entity.readOnly)

        obj.setChanged(false);
#end
        
        return obj;
    }
    
    /**
     * Permite obter todos os registos da tabela $entity.name que respeitam o filtro com a possibilidade de restringir o numero de registos devolvidos
     * @param filter Filtro com as restrições a aplicar
     * @param skipRows Numero de registos a ignorar (0 - Não ignora registos)
     * @param maxRows Numero maximo de registos a devolver (0 - Sem limite)     
     * @return Lista de instancias da classe ${java.getName($entity)}
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     */
    public Collection#if(${java6.booleanValue()})<${java.getName($entity)}>#end findByFilter(Filter filter, int skipRows, int maxRows) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("findByFilter(..., " + skipRows + ", " + maxRows + ")");
        }
		            
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        
        List#if(${java6.booleanValue()})<${java.getName($entity)}>#end list = new ArrayList#if(${java6.booleanValue()})<${java.getName($entity)}>#end();

        try {
            con = DBUtil.getConnection(getDataSource());
     
#if($model.isTable($entity))
            ps = con.prepareStatement(SQLUtil.getSelectForTable(TABLE_NAME, filter), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
#else
            ps = con.prepareStatement(SQLUtil.getUpdatedSelect("$entity.sql", filter), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
#end                        
            ps.setMaxRows(skipRows + maxRows);

            filter.setValues(ps);

            rs = ps.executeQuery();
            
            if (skipRows == 0 || rs.absolute(skipRows)) {
                while (rs.next()) {
                    list.add(readObject(rs));
                }
            }
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing findByFilter(..., " + skipRows + ", " + maxRows + ")", e);
            throw new SQLError(e);   
        } catch (Exception e) { 
            ${loggerType}.error("Exception catched while executing findByFilter(..., " + skipRows + ", " + maxRows + ")", e);
            throw new UnexpectedError(e);                                     
        } finally {
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        return list;
    }  
    
    /**
     * Permite obter todos os registos da tabela $entity.name
     * @return Lista de instancias da classe ${java.getName($entity)}
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     */
    public Collection#if(${java6.booleanValue()})<${java.getName($entity)}>#end findAll() throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("findAll()");
        }
		            
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        
        List#if(${java6.booleanValue()})<${java.getName($entity)}>#end list = new ArrayList#if(${java6.booleanValue()})<${java.getName($entity)}>#end();

        try {
            con = DBUtil.getConnection(getDataSource());
            ps = con.prepareStatement("${sql.getSelectAll($entity)}", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);

            rs = ps.executeQuery();
        
            while (rs.next()) {
                list.add(readObject(rs));
            }
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing findAll()", e);
            throw new SQLError(e);  
        } catch (Exception e) { 
            ${loggerType}.error("Exception catched while executing findAll()", e);
            throw new UnexpectedError(e);               
        } finally {
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        return list;
    } 
    
    /**
     * Permite obter o numero de registos na tabela $entity.name
     * @return Numero de registos
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     */    
    public long count() throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("count()");
        }
		            
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        
        long ret = 0;

        try {
            con = DBUtil.getConnection(getDataSource());
            ps = con.prepareStatement("${sql.getSelectCount($entity)}", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);

            rs = ps.executeQuery();

            if (rs.next()) {
                ret = rs.getLong(1);
            }
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing count()", e);
            throw new SQLError(e);  
        } catch (Exception e) {  
            ${loggerType}.error("Exception catched while executing count()", e);
            throw new UnexpectedError(e);                         
        } finally {
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        return ret;
    }   
#if($model.isTable($entity))
    
    /**
     * Permite obter o numero de registos na tabela $entity.name que respeitam o filtro
     * @param filter Filtro com as restrições a aplicar     
     * @return Numero de registos
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     */    
    public long count(Filter filter) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("count(...)");
        }
		            
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        
        long ret = 0;

        try {
            con = DBUtil.getConnection(getDataSource());
            
            StringBuffer buffer = new StringBuffer();
                        
            buffer.append("SELECT COUNT(*) FROM $entity.name");            
            
            if (filter.hasWhere()) {
                buffer.append(" WHERE ");            
                buffer.append(filter.getWhereSQL());
            }
            
            ps = con.prepareStatement(buffer.toString(), ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);

            filter.setValues(ps);
            
            rs = ps.executeQuery();

            if (rs.next()) {
                ret = rs.getLong(1);
            }
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing count(...)", e);
            throw new SQLError(e);   
        } catch (Exception e) {
            ${loggerType}.error("Exception catched while executing count(...)", e);
            throw new UnexpectedError(e);                                     
        } finally {
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        return ret;
    }   
#end      
#if($model.hasForeignKey($entity))   
#foreach($fk in $entity.getForeignKeyList())
#set ($fkEntity = $model.getFKEntity($fk))

#if (${fk.isOneToOne()})
    /**
     * Permite obter o registo da tabela $entity.name que referencia a tabela $fkEntity.name
     * @param fk Instancia da classe ${java.getName($fkEntity)}
     * @return Instancias da classe ${java.getName($entity)}
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     */
    public ${java.getName($entity)} findBy${java.getName($fk)}(${java.getName($fkEntity)} fk) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("findBy${java.getName($fk)}(" + fk + ")");
        }
		        
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        
        ${java.getName($entity)} ret = null;

        try {
            con = DBUtil.getConnection(getDataSource());
            ps = con.prepareStatement("${sql.getSelectByFK($fk)}", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);

#set($primeira=1)
#foreach ($coluna in ${fk.getForeignColumnList()})
            ps.${java.getJavaTypeSetter($entity.getColumn($coluna.columnName))}($primeira, fk.${java.getGetter($fkEntity.getColumn($coluna.referencedColumn))}());
#set($primeira=$primeira+1)
#end

            rs = ps.executeQuery();
        
            if (rs.next()) {
                ret = readObject(rs);
            }
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing findBy${java.getName($fk)}(" + fk + ")", e);
            throw new SQLError(e); 
        } catch (Exception e) { 
            ${loggerType}.error("Exception catched while executing findBy${java.getName($fk)}(" + fk + ")", e);
            throw new UnexpectedError(e);                                   
        } finally {
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        return ret;
    }
#else
    /**
     * Permite obter todos os registos da tabela $entity.name que referenciam a tabela $fkEntity.name
     * @param fk Instancia da classe ${java.getName($fkEntity)}
     * @return Lista de instancias da classe ${java.getName($entity)}
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     */
    public Collection#if(${java6.booleanValue()})<${java.getName($entity)}>#end findBy${java.getName($fk)}(${java.getName($fkEntity)} fk) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("findBy${java.getName($fk)}(" + fk + ")");
        }
		        
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        
        List#if(${java6.booleanValue()})<${java.getName($entity)}>#end list = new ArrayList#if(${java6.booleanValue()})<${java.getName($entity)}>#end();

        try {
            con = DBUtil.getConnection(getDataSource());
            ps = con.prepareStatement("${sql.getSelectByFK($fk)}", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);

#set($primeira=1)
#foreach ($coluna in ${fk.getForeignColumnList()})
            ps.${java.getJavaTypeSetter($entity.getColumn($coluna.columnName))}($primeira, fk.${java.getGetter($fkEntity.getColumn($coluna.referencedColumn))}());
#set($primeira=$primeira+1)
#end

            rs = ps.executeQuery();
        
            while (rs.next()) {
                list.add(readObject(rs));
            }
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing findBy${java.getName($fk)}(" + fk + ")", e);
            throw new SQLError(e);    
        } catch (Exception e) {                      
            ${loggerType}.error("Exception catched while executing findBy${java.getName($fk)}(" + fk + ")", e);
            throw new UnexpectedError(e);            
        } finally {
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        return list;
    }
#end
#end
#end 
#if($model.hasFinders($entity))   
#foreach($finder in $entity.getFinderList())

#if ($model.isFinderReturnCollection($finder))
    /**
     * Permite obter todos os registos da tabela $entity.name que respeitam a query "${sql.getSelectForFinder($finder)}"
#foreach ($parametro in ${finder.getUniqueParameterList()})	     
     * @param ${parametro.name} Valor do parametro ${parametro.name}
#end	     
     * @return Lista de instancias da classe ${java.getName($entity)}
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     */
    public Collection#if(${java6.booleanValue()})<${java.getName($entity)}>#end ${finder.name}(#set ($primeira=1)#foreach ($parametro in ${finder.getUniqueParameterList()})#if ($primeira==1)${parametro.javaType} ${parametro.name}#set ($primeira=0)#else, ${parametro.javaType} ${parametro.name}#end#end) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("${finder.name}(#set ($primeira=1)#foreach ($parametro in ${finder.getUniqueParameterList()})#if ($primeira==1)" + ${parametro.name} + "#set ($primeira=0)#else, " + ${parametro.name} + "#end#end)");
        }
		            
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
#if ($finder.dirtyReads)
        Integer isolation = null;
#end        
        
        List#if(${java6.booleanValue()})<${java.getName($entity)}>#end list = new ArrayList#if(${java6.booleanValue()})<${java.getName($entity)}>#end();

        try {
            con = DBUtil.getConnection(getDataSource());
#if ($finder.dirtyReads)
            isolation = new Integer(con.getTransactionIsolation());
            con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);

#end            
            ps = con.prepareStatement("${sql.getSelectForFinder($finder)}", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);

#set($primeira=1)
#foreach ($parametro in ${finder.getParameterList()})
#if($java.isWrapperClass($parametro))

            if (${parametro.name} == null) {
                ps.setNull($primeira, Types.$java.getSQLType($parametro));
            } else {
                ps.${java.getJavaTypeSetter($parametro)}($primeira, ${parametro.name}#if($java.isWrapperClass($parametro))$java.primitiveGetter($parametro)#end);                        
            }
        
#else
            ps.${java.getJavaTypeSetter($parametro)}($primeira, ${parametro.name});
#end  
#set($primeira=$primeira+1)
#end

            rs = ps.executeQuery();
        
            while (rs.next()) {
                list.add(readObject(rs));
            }
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing ${finder.name}(#set ($primeira=1)#foreach ($parametro in ${finder.getUniqueParameterList()})#if ($primeira==1)" + ${parametro.name} + "#set ($primeira=0)#else, " + ${parametro.name} + "#end#end)", e);
            throw new SQLError(e);  
        } catch (Exception e) {
            ${loggerType}.error("Exception catched while executing ${finder.name}(#set ($primeira=1)#foreach ($parametro in ${finder.getUniqueParameterList()})#if ($primeira==1)" + ${parametro.name} + "#set ($primeira=0)#else, " + ${parametro.name} + "#end#end)", e);
            throw new UnexpectedError(e);                                     
        } finally {
#if ($finder.dirtyReads)
            if (isolation != null) {
            	try {
            		con.setTransactionIsolation(isolation.intValue());
            	} catch (SQLException ei) {}
            }

#end        
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        return list;
    }
#if ($model.hasLimits($finder))

    /**
     * Permite obter todos os registos da tabela $entity.name que respeitam a query "${sql.getSelectForFinder($finder)}" com a possibilidade de restringir o numero de registos devolvidos
#foreach ($parametro in ${finder.getUniqueParameterList()})	     
     * @param ${parametro.name} Valor do parametro ${parametro.name}
#end	     
     * @param skipRows Numero de registos a ignorar (0 - Não ignora registos)
     * @param maxRows Numero maximo de registos a devolver (0 - Sem limite)     
     * @return Lista de instancias da classe ${java.getName($entity)}
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     */
    public Collection#if(${java6.booleanValue()})<${java.getName($entity)}>#end ${finder.name}(#set ($primeira=1)#foreach ($parametro in ${finder.getUniqueParameterList()})#if ($primeira==1)${parametro.javaType} ${parametro.name}#set ($primeira=0)#else, ${parametro.javaType} ${parametro.name}#end#end#if($primeira==0),#end int skipRows, int maxRows) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("${finder.name}(#set ($primeira=1)#foreach ($parametro in ${finder.getUniqueParameterList()})#if ($primeira==1)" + ${parametro.name} + "#set ($primeira=0)#else, " + ${parametro.name} + "#end#end#if($primeira==0),#end " + skipRows + ", " + maxRows + ")");
        }
		            
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
#if ($finder.dirtyReads)
        Integer isolation = null;
#end         
        
        List#if(${java6.booleanValue()})<${java.getName($entity)}>#end list = new ArrayList#if(${java6.booleanValue()})<${java.getName($entity)}>#end();

        try {
            con = DBUtil.getConnection(getDataSource());
#if ($finder.dirtyReads)
            isolation = new Integer(con.getTransactionIsolation());
            con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);

#end               
            ps = con.prepareStatement("${sql.getSelectForFinder($finder)}", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
            ps.setMaxRows(skipRows + maxRows);

#set($primeira=1)
#foreach ($parametro in ${finder.getParameterList()})
#if($java.isWrapperClass($parametro))

            if (${parametro.name} == null) {
                ps.setNull($primeira, Types.$java.getSQLType($parametro));
            } else {
                ps.${java.getJavaTypeSetter($parametro)}($primeira, ${parametro.name}#if($java.isWrapperClass($parametro))$java.primitiveGetter($parametro)#end);                        
            }
        
#else
            ps.${java.getJavaTypeSetter($parametro)}($primeira, ${parametro.name});
#end  
#set($primeira=$primeira+1)
#end

            rs = ps.executeQuery();
            
            if (skipRows == 0 || rs.absolute(skipRows)) {
                while (rs.next()) {
                    list.add(readObject(rs));
                }
            }
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing ${finder.name}(#set ($primeira=1)#foreach ($parametro in ${finder.getUniqueParameterList()})#if ($primeira==1)" + ${parametro.name} + "#set ($primeira=0)#else, " + ${parametro.name} + "#end#end#if($primeira==0),#end " + skipRows + ", " + maxRows + ")", e);
            throw new SQLError(e); 
        } catch (Exception e) {  
            ${loggerType}.error("Exception catched while executing ${finder.name}(#set ($primeira=1)#foreach ($parametro in ${finder.getUniqueParameterList()})#if ($primeira==1)" + ${parametro.name} + "#set ($primeira=0)#else, " + ${parametro.name} + "#end#end#if($primeira==0),#end " + skipRows + ", " + maxRows + ")", e);
            throw new UnexpectedError(e);                                    
        } finally {
#if ($finder.dirtyReads)
            if (isolation != null) {
            	try {
            		con.setTransactionIsolation(isolation.intValue());
            	} catch (SQLException ei) {}
            }

#end           
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        return list;
    }
#end    
#else
#if ($model.isFinderReturnVoid($finder))
    /**
     * Permite obter os registos da tabela $entity.name que respeita a query "${sql.getSelectForFinder($finder)}"
     * @param callback Objecto que irá processar cada um dos registos encontrados (possui o método: public void process(${java.getName($entity)} obj))
#foreach ($parametro in ${finder.getUniqueParameterList()})	     
     * @param ${parametro.name} Valor do parametro ${parametro.name}
#end	     
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro na invocação do objecto de callback
     */
    public void ${finder.name}(Object callback#foreach ($parametro in ${finder.getUniqueParameterList()}), ${parametro.javaType} ${parametro.name}#end) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("${finder.name}(...#foreach ($parametro in ${finder.getUniqueParameterList()}), " + ${parametro.name} + "#end)");
        }
		            
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
#if ($finder.dirtyReads)
        Integer isolation = null;
#end        
        
        BeanUtil callbackUtil = new BeanUtil(callback);
        Object[] callbackArgs = new Object[1];

        try {
            con = DBUtil.getConnection(getDataSource());
#if ($finder.dirtyReads)
            isolation = new Integer(con.getTransactionIsolation());
            con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);

#end            
            ps = con.prepareStatement("${sql.getSelectForFinder($finder)}", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
            
#set($primeira=1)
#foreach ($parametro in ${finder.getParameterList()})
#if($java.isWrapperClass($parametro))

            if (${parametro.name} == null) {
                ps.setNull($primeira, Types.$java.getSQLType($parametro));
            } else {
                ps.${java.getJavaTypeSetter($parametro)}($primeira, ${parametro.name}#if($java.isWrapperClass($parametro))$java.primitiveGetter($parametro)#end);                        
            }
        
#else
            ps.${java.getJavaTypeSetter($parametro)}($primeira, ${parametro.name});
#end  
#set($primeira=$primeira+1)
#end

            rs = ps.executeQuery();
        
            while (rs.next()) {
                callbackArgs[0] = readObject(rs);
                callbackUtil.invokeMethod("process", callbackArgs);
            }                             
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing ${finder.name}(...#foreach ($parametro in ${finder.getUniqueParameterList()}), " + ${parametro.name} + "#end)", e);
            throw new SQLError(e);                  
        } catch (Exception e) {     
            ${loggerType}.error("Exception catched while trying to execute method public void process(${java.getName($entity)} obj) on object " + callback.getClass().getName() + " in finder ${finder.name}(...#foreach ($parametro in ${finder.getUniqueParameterList()}), " + ${parametro.name} + "#end)", e);
            throw new UnexpectedError(e);             
        } finally {
#if ($finder.dirtyReads)
            if (isolation != null) {
            	try {
            		con.setTransactionIsolation(isolation.intValue());
            	} catch (SQLException ei) {}
            }

#end         
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
    }     
#if ($model.hasLimits($finder))

    /**
     * Permite obter os registos da tabela $entity.name que respeita a query "${sql.getSelectForFinder($finder)}"  com a possibilidade de restringir o numero de registos devolvidos
     * @param callback Objecto que irá processar cada um dos registos encontrados (possui o método: public void process(${java.getName($entity)} obj))
#foreach ($parametro in ${finder.getUniqueParameterList()})	     
     * @param ${parametro.name} Valor do parametro ${parametro.name}
#end	     
     * @param skipRows Numero de registos a ignorar (0 - Não ignora registos)
     * @param maxRows Numero maximo de registos a devolver (0 - Sem limite)  
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro na invocação do objecto de callback
     */
    public void ${finder.name}(Object callback#foreach ($parametro in ${finder.getUniqueParameterList()}), ${parametro.javaType} ${parametro.name}#end, int skipRows, int maxRows) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("${finder.name}(...#foreach ($parametro in ${finder.getUniqueParameterList()}), " + ${parametro.name} + "#end, " + skipRows + ", " + maxRows + ")");
        }
		            
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
#if ($finder.dirtyReads)
        Integer isolation = null;
#end        
        
        BeanUtil callbackUtil = new BeanUtil(callback);
        Object[] callbackArgs = new Object[1];

        try {
            con = DBUtil.getConnection(getDataSource());
#if ($finder.dirtyReads)
            isolation = new Integer(con.getTransactionIsolation());
            con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);

#end             
            ps = con.prepareStatement("${sql.getSelectForFinder($finder)}", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
            ps.setMaxRows(skipRows + maxRows);

#set($primeira=1)
#foreach ($parametro in ${finder.getParameterList()})
#if($java.isWrapperClass($parametro))

            if (${parametro.name} == null) {
                ps.setNull($primeira, Types.$java.getSQLType($parametro));
            } else {
                ps.${java.getJavaTypeSetter($parametro)}($primeira, ${parametro.name}#if($java.isWrapperClass($parametro))$java.primitiveGetter($parametro)#end);                        
            }
        
#else
            ps.${java.getJavaTypeSetter($parametro)}($primeira, ${parametro.name});
#end  
#set($primeira=$primeira+1)
#end

            rs = ps.executeQuery();

            if (skipRows == 0 || rs.absolute(skipRows)) {        
                while (rs.next()) {
                    callbackArgs[0] = readObject(rs);
                    callbackUtil.invokeMethod("process", callbackArgs);
                }
            }
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing ${finder.name}(...#foreach ($parametro in ${finder.getUniqueParameterList()}), " + ${parametro.name} + "#end, " + skipRows + ", " + maxRows + ")", e);
            throw new SQLError(e);                  
        } catch (Exception e) {     
            ${loggerType}.error("Exception catched while trying to execute method public void process(${java.getName($entity)} obj) on object " + callback.getClass().getName() + " in finder ${finder.name}(...#foreach ($parametro in ${finder.getUniqueParameterList()}), " + ${parametro.name} + "#end, " + skipRows + ", " + maxRows + ")", e);
            throw new UnexpectedError(e);             
        } finally {
#if ($finder.dirtyReads)
            if (isolation != null) {
            	try {
            		con.setTransactionIsolation(isolation.intValue());
            	} catch (SQLException ei) {}
            }

#end        
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
    }
#end      
#else
    /**
     * Permite obter o registo da tabela $entity.name que respeita a query "${sql.getSelectForFinder($finder)}"
#foreach ($parametro in ${finder.getUniqueParameterList()})	     
     * @param ${parametro.name} Valor do parametro ${parametro.name}
#end	     
     * @return Instancia da classe ${java.getName($entity)}
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     */
    public ${java.getName($entity)} ${finder.name}(#set ($primeira=1)#foreach ($parametro in ${finder.getUniqueParameterList()})#if ($primeira==1)${parametro.javaType} ${parametro.name}#set ($primeira=0)#else, ${parametro.javaType} ${parametro.name}#end#end) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("${finder.name}(#set ($primeira=1)#foreach ($parametro in ${finder.getUniqueParameterList()})#if ($primeira==1)" + ${parametro.name} + "#set ($primeira=0)#else, " + ${parametro.name} + "#end#end)");
        }
		            
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
#if ($finder.dirtyReads)
        Integer isolation = null;
#end        
        
        ${java.getName($entity)} obj = null;

        try {
            con = DBUtil.getConnection(getDataSource());
#if ($finder.dirtyReads)
            isolation = new Integer(con.getTransactionIsolation());
            con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);

#end            
            ps = con.prepareStatement("${sql.getSelectForFinder($finder)}", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);

#set($primeira=1)
#foreach ($parametro in ${finder.getParameterList()})
#if($java.isWrapperClass($parametro))

            if (${parametro.name} == null) {
                ps.setNull($primeira, Types.$java.getSQLType($parametro));
            } else {
                ps.${java.getJavaTypeSetter($parametro)}($primeira, ${parametro.name}#if($java.isWrapperClass($parametro))$java.primitiveGetter($parametro)#end);                        
            }
        
#else
            ps.${java.getJavaTypeSetter($parametro)}($primeira, ${parametro.name});
#end  
#set($primeira=$primeira+1)
#end

            rs = ps.executeQuery();
        
            if (rs.next()) {
                obj = readObject(rs);
            }
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing ${finder.name}(#set ($primeira=1)#foreach ($parametro in ${finder.getUniqueParameterList()})#if ($primeira==1)" + ${parametro.name} + "#set ($primeira=0)#else, " + ${parametro.name} + "#end#end)", e);
            throw new SQLError(e);  
        } catch (Exception e) {
            ${loggerType}.error("Exception catched while executing ${finder.name}(#set ($primeira=1)#foreach ($parametro in ${finder.getUniqueParameterList()})#if ($primeira==1)" + ${parametro.name} + "#set ($primeira=0)#else, " + ${parametro.name} + "#end#end)", e);
            throw new UnexpectedError(e);                          
        } finally {
#if ($finder.dirtyReads)
            if (isolation != null) {
            	try {
            		con.setTransactionIsolation(isolation.intValue());
            	} catch (SQLException ei) {}
            }

#end        
            DBUtil.close(rs);
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        return obj;
    }     
#end    
#end
#end
#end 
#if($model.hasOperations($entity))   
#foreach($operation in $entity.getOperationList())

    /**
     * Executa o SQL "${sql.getOperationSQL($operation)}"
#foreach ($parametro in ${operation.getUniqueParameterList()})	     
     * @param ${parametro.name} Valor do parametro ${parametro.name}
#end	     
     * @return Numero de registos alterados
     * @throws SQLError Se ocorrer um erro no acesso à Base de Dados
     * @throws UnexpectedError Se ocorrer um erro inesperado     
     */
    public int ${operation.name}(#set ($primeira=1)#foreach ($parametro in ${operation.getUniqueParameterList()})#if ($primeira==1)${parametro.javaType} ${parametro.name}#set ($primeira=0)#else, ${parametro.javaType} ${parametro.name}#end#end) throws SQLError, UnexpectedError {
        if (${loggerType}.isDebugEnabled()) {
            ${loggerType}.debug("${operation.name}(#set ($primeira=1)#foreach ($parametro in ${operation.getUniqueParameterList()})#if ($primeira==1)" + ${parametro.name} + "#set ($primeira=0)#else, " + ${parametro.name} + "#end#end)");
        }    
    
        Connection con = null;
        PreparedStatement ps = null;
        
        int ret = 0;

        try {
            con = DBUtil.getConnection(getDataSource());
            ps = con.prepareStatement("${sql.getOperationSQL($operation)}");

#set($primeira=1)
#foreach ($parametro in ${operation.getParameterList()})
#if($java.isWrapperClass($parametro))

            if (${parametro.name} == null) {
                ps.setNull($primeira, Types.$java.getSQLType($parametro));
            } else {
                ps.${java.getJavaTypeSetter($parametro)}($primeira, ${parametro.name}#if($java.isWrapperClass($parametro))$java.primitiveGetter($parametro)#end);                        
            }
        
#else
            ps.${java.getJavaTypeSetter($parametro)}($primeira, ${parametro.name});
#end            
#set($primeira=$primeira+1)
#end

            ret = ps.executeUpdate();
        } catch (SQLException e) {     
            ${loggerType}.error("SQLException catched while executing ${operation.name}(#set ($primeira=1)#foreach ($parametro in ${operation.getUniqueParameterList()})#if ($primeira==1)" + ${parametro.name} + "#set ($primeira=0)#else, " + ${parametro.name} + "#end#end)", e);
            throw new SQLError(e);   
        } catch (Exception e) {
            ${loggerType}.error("Exception catched while executing ${operation.name}(#set ($primeira=1)#foreach ($parametro in ${operation.getUniqueParameterList()})#if ($primeira==1)" + ${parametro.name} + "#set ($primeira=0)#else, " + ${parametro.name} + "#end#end)", e);
            throw new UnexpectedError(e);                       
        } finally {
            DBUtil.close(ps);
            DBUtil.close(con);
        }
        
        return ret;
    }
#end 
#end
}
